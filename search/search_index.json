{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"DelFEM2 DelFEM2 is a toolset for Finite Element Analsys with Python/C++ Seemless integration with Numpy. Integrated CAD / Mesher / Solver / Visualizer Features Built in mesh generation 2D triangle mesh (Delaunay triangulation) 3D tetrahedra mesh (Isosurface stuffing) Dynamic remesh Built in sparse linar solver Congugate gradient method BiCGStab method ILU(0) preconditioner Supports many equations on many types of mesh Poission's equation (Tri P1, Tet P1) Diffusion equation (Tri P1, Tet P1) Linear solid equation (Tri P1, Tet P1) Simulation of cloth (Tri P1) Storkes equation (Tri P1, Tet P1) Navier-Storkes equation with PSPG-SUPG stabilization (Tri P1) Visualization color contour mesh displacement IO VTK file output Download Please download the latest project by cloning the GitHub repository Project layout docs # This document src_cpp / cpp # cpp files include # include files for cpp external # external dependencies module_py dfm2 # python module folder example_cpp # cpp examples example_py # python examples test # Unit tests for C++/Python test_inputs # Input files for test Use DelFEM2 from Python To build the python module pleese see building instruction . For the examples see python examples . Use DelFEM2 from C++ See the cpp examples Licence & Copyright DelFEM2 is distributed under the MIT licence . In a nut shell, it is free to use/distribute this software commercially for any purpose. But please always keep the copyright notice below and the MIT lisence statement. Copyright ( C ) Nobuyuki Umetani 2019 Contact DelFEM2 is currently developed and maintained by Nobuyuki Umetani . If you have questions or comments please contact .","title":"Home"},{"location":"#delfem2","text":"DelFEM2 is a toolset for Finite Element Analsys with Python/C++ Seemless integration with Numpy. Integrated CAD / Mesher / Solver / Visualizer","title":"DelFEM2"},{"location":"#features","text":"Built in mesh generation 2D triangle mesh (Delaunay triangulation) 3D tetrahedra mesh (Isosurface stuffing) Dynamic remesh Built in sparse linar solver Congugate gradient method BiCGStab method ILU(0) preconditioner Supports many equations on many types of mesh Poission's equation (Tri P1, Tet P1) Diffusion equation (Tri P1, Tet P1) Linear solid equation (Tri P1, Tet P1) Simulation of cloth (Tri P1) Storkes equation (Tri P1, Tet P1) Navier-Storkes equation with PSPG-SUPG stabilization (Tri P1) Visualization color contour mesh displacement IO VTK file output","title":"Features"},{"location":"#download","text":"Please download the latest project by cloning the GitHub repository","title":"Download"},{"location":"#project-layout","text":"docs # This document src_cpp / cpp # cpp files include # include files for cpp external # external dependencies module_py dfm2 # python module folder example_cpp # cpp examples example_py # python examples test # Unit tests for C++/Python test_inputs # Input files for test","title":"Project layout"},{"location":"#use-delfem2-from-python","text":"To build the python module pleese see building instruction . For the examples see python examples .","title":"Use DelFEM2 from Python"},{"location":"#use-delfem2-from-c","text":"See the cpp examples","title":"Use DelFEM2 from C++"},{"location":"#licence-copyright","text":"DelFEM2 is distributed under the MIT licence . In a nut shell, it is free to use/distribute this software commercially for any purpose. But please always keep the copyright notice below and the MIT lisence statement. Copyright ( C ) Nobuyuki Umetani 2019","title":"Licence &amp; Copyright"},{"location":"#contact","text":"DelFEM2 is currently developed and maintained by Nobuyuki Umetani . If you have questions or comments please contact .","title":"Contact"},{"location":"coding/","text":"Coding Convention Overall remove dependency between the codes as much as possible low level code must compile C++98 use double space for a tab Element Indexing Rule Based on the elemnt index rule in VTK Coordinate for the Depth Computation Naming Convention (cpp) use the extension \".h\" instead of \".hpp\" filename should be in lower case. The underscore represent depndency. For example \"aa_bb.cpp\" means this is a implementation of class \"aaa\" and it depends on a class \"bbb\" The function name should be written in camel case notation that sarts with upper case letter (e.g., Verb_Object_Adverb) Geometric Operator Nearest Intersection IsInside Volume Area Use Read <-> Write for the file io. Don't use Load <-> Save Naming Various Types of Points aXY -> general 2D point aXYZ-> general 3D point CAD vertex -> Vertex Mesh corner point -> Point FEM points it can be inside an element (may be on edge or on face) -> Node How to call a mesh? MeshTri3D MeshQuad2D MeshHex3D MeshMix3D MeshElem3D Point3D MeshHex3DSurface","title":"Coding Convention"},{"location":"coding/#coding-convention","text":"","title":"Coding Convention"},{"location":"coding/#overall","text":"remove dependency between the codes as much as possible low level code must compile C++98 use double space for a tab","title":"Overall"},{"location":"coding/#element-indexing-rule","text":"Based on the elemnt index rule in VTK","title":"Element Indexing Rule"},{"location":"coding/#coordinate-for-the-depth-computation","text":"","title":"Coordinate for the Depth Computation"},{"location":"coding/#naming-convention-cpp","text":"use the extension \".h\" instead of \".hpp\" filename should be in lower case. The underscore represent depndency. For example \"aa_bb.cpp\" means this is a implementation of class \"aaa\" and it depends on a class \"bbb\" The function name should be written in camel case notation that sarts with upper case letter (e.g., Verb_Object_Adverb) Geometric Operator Nearest Intersection IsInside Volume Area Use Read <-> Write for the file io. Don't use Load <-> Save Naming Various Types of Points aXY -> general 2D point aXYZ-> general 3D point CAD vertex -> Vertex Mesh corner point -> Point FEM points it can be inside an element (may be on edge or on face) -> Node How to call a mesh? MeshTri3D MeshQuad2D MeshHex3D MeshMix3D MeshElem3D Point3D MeshHex3DSurface","title":"Naming Convention (cpp)"},{"location":"example_cpp/","text":"Examples (C++) Build C++ Examples cd examples_cpp mkdir buildMake cd buildMake cmake .. make triangulation Dynamic Remesh Transform Handler cloth_internal subdiv read_bvh exponential_map selfcollision_bvh edge_collapse","title":"Examples (C++)"},{"location":"example_cpp/#examples-c","text":"","title":"Examples (C++)"},{"location":"example_cpp/#build-c-examples","text":"cd examples_cpp mkdir buildMake cd buildMake cmake .. make","title":"Build C++ Examples"},{"location":"example_cpp/#triangulation","text":"","title":"triangulation"},{"location":"example_cpp/#dynamic-remesh","text":"","title":"Dynamic Remesh"},{"location":"example_cpp/#transform-handler","text":"","title":"Transform Handler"},{"location":"example_cpp/#cloth_internal","text":"","title":"cloth_internal"},{"location":"example_cpp/#subdiv","text":"","title":"subdiv"},{"location":"example_cpp/#read_bvh","text":"","title":"read_bvh"},{"location":"example_cpp/#exponential_map","text":"","title":"exponential_map"},{"location":"example_cpp/#selfcollision_bvh","text":"","title":"selfcollision_bvh"},{"location":"example_cpp/#edge_collapse","text":"","title":"edge_collapse"},{"location":"example_py/","text":"Examples (Python) Solving Poisson's Equation Here is the example solving the Poisson's equation on a 2D square domain. The value on the boundary is fixed and there is a source term. import dfm2 cad = dfm2 . Cad2D ( list_xy = [ - 1 , - 1 , + 1 , - 1 , + 1 , + 1 , - 1 , + 1 ]) # define shape mesh = cad . mesh ( edge_length = 0.05 ) # generate mesh fem = dfm2 . FEM_Poisson ( mesh , source = 1.0 ) # define solver npIdP = cad . points_edge ([ 0 , 1 , 2 , 3 ], mesh . np_pos ) # indexes of points on the bondary fem . ls . vec_bc [ npIdP ] = 1 # set the fixed boundary condition fem . solve () # solve the equation field = dfm2 . Field ( mesh , val_color = fem . vec_val [:, 0 ]) # make the field for visualization dfm2 . winDraw3d ([ field ]) # visualization The code is implemented based o the note I wrote: Finite Element Method: Solving Poission's Equation . Solving Linear Solid Static Equation in 2D In this example the static linear solid equation is solved in the 2D square domain. The XY displacement on the left edge is fixed and the gravity is pulling the material in the direction of -Y axis. import dfm2 cad = dfm2 . Cad2D ( list_xy = [ - 1 , - 1 , + 1 , - 1 , + 1 , + 1 , - 1 , + 1 ]) mesh = cad . mesh ( edge_length = 0.05 ) fem = dfm2 . FEM_LinearSolidStatic ( mesh , gravity = [ 0 , - 0.1 ]) npIdP = cad . points_edge ([ 3 ], mesh . np_pos ) fem . ls . vec_bc [ npIdP ,:] = 1 fem . solve () field = dfm2 . Field ( mesh , val_disp = fem . vec_val ) dfm2 . winDraw3d ([ field ]) The code is implementaed based on the note I wrote Finite Element Method: Solving Linear Solid Euqation .","title":"Examples (Python)"},{"location":"example_py/#examples-python","text":"","title":"Examples (Python)"},{"location":"example_py/#solving-poissons-equation","text":"Here is the example solving the Poisson's equation on a 2D square domain. The value on the boundary is fixed and there is a source term. import dfm2 cad = dfm2 . Cad2D ( list_xy = [ - 1 , - 1 , + 1 , - 1 , + 1 , + 1 , - 1 , + 1 ]) # define shape mesh = cad . mesh ( edge_length = 0.05 ) # generate mesh fem = dfm2 . FEM_Poisson ( mesh , source = 1.0 ) # define solver npIdP = cad . points_edge ([ 0 , 1 , 2 , 3 ], mesh . np_pos ) # indexes of points on the bondary fem . ls . vec_bc [ npIdP ] = 1 # set the fixed boundary condition fem . solve () # solve the equation field = dfm2 . Field ( mesh , val_color = fem . vec_val [:, 0 ]) # make the field for visualization dfm2 . winDraw3d ([ field ]) # visualization The code is implemented based o the note I wrote: Finite Element Method: Solving Poission's Equation .","title":"Solving Poisson's Equation"},{"location":"example_py/#solving-linear-solid-static-equation-in-2d","text":"In this example the static linear solid equation is solved in the 2D square domain. The XY displacement on the left edge is fixed and the gravity is pulling the material in the direction of -Y axis. import dfm2 cad = dfm2 . Cad2D ( list_xy = [ - 1 , - 1 , + 1 , - 1 , + 1 , + 1 , - 1 , + 1 ]) mesh = cad . mesh ( edge_length = 0.05 ) fem = dfm2 . FEM_LinearSolidStatic ( mesh , gravity = [ 0 , - 0.1 ]) npIdP = cad . points_edge ([ 3 ], mesh . np_pos ) fem . ls . vec_bc [ npIdP ,:] = 1 fem . solve () field = dfm2 . Field ( mesh , val_disp = fem . vec_val ) dfm2 . winDraw3d ([ field ]) The code is implementaed based on the note I wrote Finite Element Method: Solving Linear Solid Euqation .","title":"Solving Linear Solid Static Equation in 2D"},{"location":"install/","text":"Building Instruction Linux and Mac OSX In order to build the DelFEM2 python module, you need to install several packages with the command sudo apt install git cmake download DelFEM2 from github git clone https : //github.com/nobuyuki83/delfem2.git then, download the submodules on which the DelFEM2 depends. git submodule update -- init -- recursive Next, build the DelFEM2 python module with the following command cd module_py mkdir buildMake cd buildMake cmake .. make If everything is is successful, the binary will be placed under delfem2/module_py/buildMake/ . The bindary has name dfm2.**.so where the ** is the compilation environment. The compiled binary will be automatically replaced and renamed as delfem2/module_py/dfm2/dfm2.so . This is not a recommended way of installation, but you may also use pip to install the module_py using the setup.py pip install . - e Finally, install several python modules which the DelFEM2 depends on as python3 - m pip install numpy PyOpenGL glfw Try running the python examples in delfem2/example_py/ . If the examples work congraturations!! I hope you enjoy the library.","title":"Building Instruction"},{"location":"install/#building-instruction","text":"","title":"Building Instruction"},{"location":"install/#linux-and-mac-osx","text":"In order to build the DelFEM2 python module, you need to install several packages with the command sudo apt install git cmake download DelFEM2 from github git clone https : //github.com/nobuyuki83/delfem2.git then, download the submodules on which the DelFEM2 depends. git submodule update -- init -- recursive Next, build the DelFEM2 python module with the following command cd module_py mkdir buildMake cd buildMake cmake .. make If everything is is successful, the binary will be placed under delfem2/module_py/buildMake/ . The bindary has name dfm2.**.so where the ** is the compilation environment. The compiled binary will be automatically replaced and renamed as delfem2/module_py/dfm2/dfm2.so . This is not a recommended way of installation, but you may also use pip to install the module_py using the setup.py pip install . - e Finally, install several python modules which the DelFEM2 depends on as python3 - m pip install numpy PyOpenGL glfw Try running the python examples in delfem2/example_py/ . If the examples work congraturations!! I hope you enjoy the library.","title":"Linux and Mac OSX"}]}